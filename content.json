{"meta":{"title":"Markfred Chen","subtitle":"Keep Searching Sparkle of Life","description":null,"author":"Markfred Chen","url":"https://markfredchen.github.io"},"pages":[],"posts":[{"title":"Spring Boot中使用Liquibase最佳实践","slug":"SpringBootLiquibaseTips","date":"2018-10-09T09:45:43.000Z","updated":"2018-10-10T08:18:37.919Z","comments":true,"path":"2018/10/09/SpringBootLiquibaseTips/","link":"","permalink":"https://markfredchen.github.io/2018/10/09/SpringBootLiquibaseTips/","excerpt":"","text":"背景Liquibase问题随着项目的发展，一个项目中的代码量会非常庞大，同时数据库表也会错综复杂。如果一个项目使用了Liquibase对数据库结构进行管理，越来越多的问题会浮现出来。 ChangeSet文件同时多人在修改，自己的ChangeSet被改掉，甚至被删除掉。 开发人员将ChangeSet添加到已经执行过的文件中，导致执行顺序出问题。 开发人员擅自添加对业务数据的修改，其它环境无法执行并报错。 ChangeSet中SQL包含schema名称，导致其它环境schema名称变化时，ChangeSet报错。 开发人员不小心改动了已经执行过的ChangeSet，在启动时会报错。 Liquibase基本规范 ChangeSet id使用[任务ID]-[日期]-[序号]，如 T100-20181009-001 ChangeSet必须填写author Liquibase禁止对业务数据进行sql操作 使用&lt;sql&gt;时，禁止包含schema名称 Liquibase禁止使用存储过程 所有表，列要加remarks进行注释 已经执行过的ChangeSet严禁修改。 不要随便升级项目liquibase版本，特别是大版本升级。不同版本ChangeSet MD5SUM的算法不一样。 其它数据库规范不再赘述。1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;databaseChangeLog xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.liquibase.org/xml/ns/dbchangelog\" xsi:schemaLocation=\"http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd\"&gt; &lt;changeSet id=\"T100-20181009-001\" author=\"markfredchen\" &gt; &lt;createTable tableName=\"demo_user\" remarks=\"用户表\"&gt; &lt;column name=\"id\" type=\"bigint\" remarks=\"用户ID,主键\"&gt; &lt;constraints nullable=\"false\" primaryKey=\"true\" primaryKeyName=\"pk_demo_user_id\"/&gt; &lt;/column&gt; &lt;column name=\"username\" type=\"varchar(100)\" remarks=\"用户名\"&gt; &lt;constraints nullable=\"false\"/&gt; &lt;/column&gt; ... &lt;/createTable&gt; &lt;/changeSet&gt;&lt;/databaseChangeLog&gt; 有效文件管理使用Liquibase中提供&lt;include file=&quot;xxx&quot;/&gt;tag，可以将ChangeSet分布在不同文件中。同时&lt;include/&gt;支持多级引用。基于此功能可以对项目中的ChangeSet进行有效管理。推荐使用以下规范进行管理。 根据发布进行管理 每个发布新建一个文件夹，所有发布相关的ChangeSet文件以及数据初始化文件，均放在些文件夹中。 每个发布新建一个master.xml。此master.xml中，include本次发布需要执行的ChangeSet文件 根据开发小组独立ChangeSet文件(可选) 根据功能独立ChangeSet文件。例如user.xml, company.xml123456789101112resources |-liquibase |-user | |- master.xml | |- release.1.0.0 | | |- release.xml | | |- user.xml -- 用户相关表ChangeSet | | |- user.csv -- 用户初始化数据 | | |- company.xml -- 公司相关表ChangeSet | |- release.1.1.0 | | |- release.xml | | |- ... 模块化管理当项目变得庞大之后，一个服务可能包含的功能模块会越来越多。此时大家会想尽办法进行模块拆分，逐步进行微服务化。然而在面对错综复杂的Liquibase ChangeSet就会无从下手。针对这种将来可能会面对的问题，项目初期就对Liquibase进行模块化管理，将在未来带来很大收益。首先说明一下Spring Boot中Liquibase默认是如何执行以及执行结果。 在启动时，LiquibaseAutoConfiguration会根据默认配置初始化SpringLiquibase SpringLiquibase.afterPropertiesSet()中执行ChangeSet文件 第一次跑ChangeSets的时候，会在数据库中自动创建两个表databasechangelog和databasechangeloglock 因此我们可以认为一个SpringLiquibase执行为一个模块。 引入多模块管理时，基于上节文件管理规范，我们基于模块管理再做下调整。12345678910111213141516resources |-liquibase |-user | |- master.xml | |- release.1.0.0 | | |- release.xml | | |- user.xml -- 用户相关表ChangeSet | | |- user.csv -- 用户初始化数据 | | |- company.xml -- 公司相关表ChangeSet | |- release.1.1.0 | | |- release.xml | | |- ... |- order | |- master.xml | |- release.1.0.0 | | |- ... 当有一天我们需要把订单模块拆分成独立服务时，我们只需要将模块相关的ChangeSet文件迁出来。即可完成数据结构的拆分。 那如何在一个Spring Boot运行多个SpringLiquibase呢？需要对代码进行以下调整。 禁用Spring Boot自动运行Liquibase。当以下配置被启用时，Spring Boot AutoConfigure会使用默认配置初始化名为springLiquibase的Bean。然后我们不对其进行配置，Spring Boot启动时会报错。 12345# application.properties# spring boot 2以上spring.liquibase.enabled=false# spring boot 2以下liquibase.enabled=false Spring Boot配置Liquibase Bean 配置两个SpringLiquibase Bean，Bean名称分别为userLiquibase和orderLiqubase。 12345678910111213141516171819202122232425262728293031323334@Configurationpublic class LiquibaseConfiguration() &#123; /** * 用户模块Liquibase */ @Bean public SpringLiquibase userLiquibase(DataSource dataSource) &#123; SpringLiquibase liquibase = new SpringLiquibase(); // 用户模块Liquibase文件路径 liquibase.setChangeLog(\"classpath:liquibase/user/master.xml\"); liquibase.setDataSource(dataSource); liquibase.setShouldRun(true); liquibase.setResourceLoader(new DefaultResourceLoader()); // 覆盖Liquibase changelog表名 liquibase.setDatabaseChangeLogTable(\"user_changelog_table\"); liquibase.setDatabaseChangeLogLockTable(\"user_changelog_lock_table\"); return liquibase; &#125; /** * 订单模块Liquibase */ @Bean public SpringLiquibase orderLiquibase() &#123; SpringLiquibase liquibase = new SpringLiquibase(); liquibase.setChangeLog(\"classpath:liquibase/order/master.xml\"); liquibase.setDataSource(dataSource); liquibase.setShouldRun(true); liquibase.setResourceLoader(new DefaultResourceLoader()); liquibase.setDatabaseChangeLogTable(\"order_changelog_table\"); liquibase.setDatabaseChangeLogLockTable(\"order_changelog_lock_table\"); return liquibase; &#125;&#125; Cheers~~","categories":[{"name":"后端技术","slug":"后端技术","permalink":"https://markfredchen.github.io/categories/后端技术/"},{"name":"Spring Boot","slug":"后端技术/Spring-Boot","permalink":"https://markfredchen.github.io/categories/后端技术/Spring-Boot/"}],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"https://markfredchen.github.io/tags/spring-boot/"},{"name":"liquibase","slug":"liquibase","permalink":"https://markfredchen.github.io/tags/liquibase/"}]}]}